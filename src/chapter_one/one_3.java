package chapter_one;

/*
* 338. 比特位计数
* */
public class one_3 {
    /**
     思路：
        这道题书上写了三种解法，我就用最简单的第一种了。
        第一种：就记住j & (j - 1)可以将整数i的最右边的1变为0（1100→1000）
        第二种：就是加了个像是动态规划里的memo（备忘录），就是计算新的一个数时，看看
        之前有没算过。
        第三种：最重要的是知道，i>>1是i/2；i&1是i%2。然后就是书中写的，如果i是偶数，
        那么它一的个数和i/2一样；如果i是奇数，那么它一的个数比i/2多1。
     注意：
        1.不用刻意将十进制转为二进制，不需要，直接把这个数当成二进制就行。
        2.j & (j - 1)：将j最右面的1转为0
        3.i>>1是i/2；i&1是i%2
     */
    public int[] countBits(int n) {
        // 题目是从0开始
        int[] result = new int[n + 1];
        for (int i = 0; i <= n; i++) {
            int j = i;
            while (j != 0) {
                result[i]++;
                j = j & (j - 1);
            }
        }
        return result;
    }
}
